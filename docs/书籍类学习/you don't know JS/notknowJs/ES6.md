# ES6新增的变量 let const
## let
相对于var来说，只在其所在的代码块内生效
别适合for循环的变量使用
与var的区别：
1. 不存在变量提升
2. 会出现暂时性死区概念，在一个代码块中，let声明的变量在声明之前都不可使用
3. 同一个作用域中，不允许重复声明，防止了覆盖问题。

如果在某一个作用域内使用了let 、const，那该区域会形成一个封闭的区域，只要在声明前使用这些let const变量就报错。reference error

## const
声明一个只读的变量，常量值不可更改。
且在声明初期就必须直接赋值，作用域和let相同，
1. 存在暂时性死区，只可在声明后使用。
2. 同一个作用域，不可重复声明
3. 不存在变量提升
const的本质是不许指向的变量内存地址改变

## 块作用域的概念
外层块中的变量无法读取内层的，但内层可以定义和读取外层的同名变量。

## 解构赋值
let [a, b, c] = [1, 2, 4]

let [m, ...n] = [1, 454, 666, 845]
如果不完全解构，会赋值undefined
只要具备Iterator接口，就可进行解构赋值。

同样，解构赋值允许给默认值
let [foo = true] = []

object也可解构，不过是基于变量名赋值的。
let {obj, bar} ={obj: 'ppp', bar:'zzz'} //都有值
let {obj, bar} ={obj: 'ppp', MarB:'zzz'} // 第二个不行了

解构赋值的用途
交换
[x, y] = [y, x]

提取json数据
let jsonData =  {
  id: 42,
  status: 0,
  data: {z:'s', dd: 'z'}
}

let {id, status, data: mylist} = jsonData

对象的解构赋值是找到同名属性名，在赋值给对应的变量

解构是可以赋予默认值的。
