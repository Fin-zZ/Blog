# 异步 事件循环 任务队列
任务队列（job queue）概念:
  这是一个挂载在事件循环队列的每个tick之后的 一个队列
  在事件循环的每个tick中，可能出现异步操作，这些操作的将来部分不会阻塞，
  而会在当前tick的任务队列末尾添加一个 任务，将来去做。

## 回调
  嵌套回调和链式回调形式影响我们人脑思考的顺序，也不符合我们的逻辑

  其次是采用了回调函数的是否可靠的问题，其可能出现以下问题
  1. 调用回调过早
  2. 调用回调过晚，甚至没调用
  3. 调用回调的次数太少或则和太多
  4. 没有把所需的环境/参数成功传回来
  5. 吞掉了可能出现的错误或者异常。
  6. ...
缺乏顺序性和可信任性。


## promise
所以出现了promise来解决回调的多个问题

promise对于以上5个问题的解决：
1. 调用过早
    不存在，因为传给promise的必定执行异步操作，不会被同步检测到。
2. 调用过晚
    Promise创建的对象在调用resolve 或者 reject时，必然会触发
    promise.then(..)里面的回调。一定会在下一个异步事件点⬆上触发。
3. 回调未调用
    可以借助于添加一个超时promise进行竞态
    ```js
    function timeoutPromise(delay) {
     return new Promise(resolve, reject) {
       setTimeout(()=>{
         reject()
       }, delay)
     }     
   }
   Promise.race([
     promiseA,
     timeoutPromise(3000)
   ])
   .then()
   .catch()
    ```
   
4. 调用次数过少或者过多
    正确的就是应该 1 次。
    promise响应函数只会执行一次，除非你也触发了多次
    
### Promise API

var p = new Promise(resolve, reject) {
  // resolve 用于成功
  // reject  用于失败
}

以下两个promise是等价的

var p1 = new Promise((resolve, reject) => {
  resovle('yeah')
})

var p2 = Promise.resolve('yeah')

但是呢，Promise.resolve也会展开传进来的对象的thenable值，这种情况下则返回thenable的值

```js
var fulfilled = {
  then: function(resolve, reject) {
    resolve('yyyy')
  }
}

var rejected = {
  then: function(resolve, reject) {
    reject('a')
  }
}

Promise.resolve(fulfilled)
  .then(res => {
    console.log(res)
  })
  .catch(err => {
    console.log(err)
  })

  Promise.resolve(rejected)
  .then(res => {
    console.log(res)
  })
  .catch(err => {
    console.log(err)
  })

  // yyyy
  // a
```