
# TCP

[[toc]]

TCP的几个标记位
1. SYN 建立连接
2. ACK 确认
3. FIN 关闭连接
4. PSH 传输数据
5. RST 重置
6. URG 紧急
7. CWR ECE用于拥塞控制

![tcp-header](./tcp-header.png)

### TCP三次握手
client和server建立连接过程：
1. client 发送一个TCP的SYN标志位为1的包，并设置初始序列号（Sequence number）x，
保存到包的Seq字段里。（包里还有服务器端口等信息），此时client变为了
   待连接状态
   
2. 目标server收到上述的包后，会将拿到的Seq值x加一作为Ack number的值证明拿到了，
ACK位置1，并自己也生成一个序列号y作为发送包的Seq值，也将SYN位置1，发送回去。
   此时在收到客户端发回包之前，成为半连接状态，SYN——RECV状态，接受完第三个后，
   为ESTABLISHED状态
   
3. 第三次，client再发送一个确认包，将序列号y的值加一，作为Ack number的值，并将ACK位置1
SYN不管，发送回去 即建立链接。
   
#### 不是两次的原因
1. 需要确认客户端具备接受的能力，有可能由于网络差，TCP的重发可能导致建立两个连接，使得资源浪费。
   
2. 存在一种SYN_Floud攻击，短时间内由多个ip向服务器发起连接，服务器针对每个ip形成半连接后，这些攻击的主机
下线，而服务器这边会以为网络不佳，进行重试发送，如果还没有，则会断开这个半连接。这个等待时间称为SYN_Timeout,
   多个ip这样攻击，就会白白消耗资源，使得正常用户卡顿等；
   解决的方法和特征：
   特征：某时段内连接数增多，并且SYN_RECV 连接特别多 

   - 缩短这个SYN_Timeout时间
   - 修改重试的次数，有些地方server重试次数高达5次
   - 有个昂贵的东西叫 F5，利用他作为中介，客户先与之连接，连接上后转发到业务服务器。
    
### TCP四次挥手断开连接
任何一方都可发起断开连接的请求。用主动方、被动方代替。
1. 主动方发起请求，将发送包中的FIN位置1，表示准备关闭连接，设置seq序列号m，此时发送方变为 `FIN_WAIT1`状态
   
2. 被动方收到后，将包中ACK置1，取到接收到的序列号m 并 加一作为Ack number，并发送一个自己的随机序列号n作为Seq。此时被动方
状态位`CLOSE_WAIT`状态，被动方还可发送数据给 主动方，主动方则不能够发了。主动方收到此次后，状态为`FIN_WAIT2`
   
3. 待被动方数据传输接受后，会再次发送tcp包，说明自己也可以关闭了。需要将FIN置1，ACK置1，ack number的值还是上一次的m+1，
   但这次的序列号Seq取新的 w。被动方转为`LAST_ACK`状态
   
4. 主动方收到后，会发送确认报文，将ACK置1，ack number的值为w+1,这次seq的序列号需要为对方发过来的 m + 1.此时主动方
状态TIME_WAIT,等待2MSL后，主动方进入CLOSE状态。
   
#### 为啥需要等待2MSL（2个最大报文生成时间）时间后
1. 需要保证主动方发送的关闭请求到达被动方了。
如果最后这次确认报文未送达，处理`LAST_ACK`的被动方是会重新发送一次上面的第三个FIN ACK包，这样主动方就会再次发送这个关闭
   报文，也会重置2MSL时间等待两方都进入CLOSE状态。
   
2. 防止已经失效的连接请求报文段出现
在主动方发送最后确认包2MSL后，此次连接所有报文段都会消失。比如说过了一段时间，这两个ip再次建立连接，
   那肯定不能由上一次遗留的连接在，否则状态混乱。
   
### 网络模型：
物理层

数据链路层

网络层

传输层

会话层

表示层

应用层

### UDP
是一个面向无连接的协议，
对于发送端来说，应用层给到传输层时，UDP只会将数据加个头标识就传递给网络层了，
对于接收端，传输层给到应用曾时，就是去掉ip报文头部。