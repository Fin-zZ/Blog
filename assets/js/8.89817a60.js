(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{369:function(_,v,t){_.exports=t.p+"assets/img/tcp-header.ba07fdfb.png"},398:function(_,v,t){"use strict";t.r(v);var e=t(25),a=Object(e.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"tcp"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp"}},[_._v("#")]),_._v(" TCP")]),_._v(" "),e("p"),e("div",{staticClass:"table-of-contents"},[e("ul",[e("li",[e("a",{attrs:{href:"#tcp三次握手"}},[_._v("TCP三次握手")])]),e("li",[e("a",{attrs:{href:"#tcp四次挥手断开连接"}},[_._v("TCP四次挥手断开连接")])]),e("li",[e("a",{attrs:{href:"#网络模型："}},[_._v("网络模型：")])]),e("li",[e("a",{attrs:{href:"#udp"}},[_._v("UDP")])])])]),e("p"),_._v(" "),e("p",[_._v("TCP的几个标记位")]),_._v(" "),e("ol",[e("li",[_._v("SYN 建立连接")]),_._v(" "),e("li",[_._v("ACK 确认")]),_._v(" "),e("li",[_._v("FIN 关闭连接")]),_._v(" "),e("li",[_._v("PSH 传输数据")]),_._v(" "),e("li",[_._v("RST 重置")]),_._v(" "),e("li",[_._v("URG 紧急")]),_._v(" "),e("li",[_._v("CWR ECE用于拥塞控制")])]),_._v(" "),e("p",[e("img",{attrs:{src:t(369),alt:"tcp-header"}})]),_._v(" "),e("h3",{attrs:{id:"tcp三次握手"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp三次握手"}},[_._v("#")]),_._v(" TCP三次握手")]),_._v(" "),e("p",[_._v("client和server建立连接过程：")]),_._v(" "),e("ol",[e("li",[e("p",[_._v("client 发送一个TCP的SYN标志位为1的包，并设置初始序列号（Sequence number）x，\n保存到包的Seq字段里。（包里还有服务器端口等信息），此时client变为了\n待连接状态")])]),_._v(" "),e("li",[e("p",[_._v("目标server收到上述的包后，会将拿到的Seq值x加一作为Ack number的值证明拿到了，\nACK位置1，并自己也生成一个序列号y作为发送包的Seq值，也将SYN位置1，发送回去。\n此时在收到客户端发回包之前，成为半连接状态，SYN——RECV状态，接受完第三个后，\n为ESTABLISHED状态")])]),_._v(" "),e("li",[e("p",[_._v("第三次，client再发送一个确认包，将序列号y的值加一，作为Ack number的值，并将ACK位置1\nSYN不管，发送回去 即建立链接。")])])]),_._v(" "),e("h4",{attrs:{id:"不是两次的原因"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#不是两次的原因"}},[_._v("#")]),_._v(" 不是两次的原因")]),_._v(" "),e("ol",[e("li",[e("p",[_._v("需要确认客户端具备接受的能力，有可能由于网络差，TCP的重发可能导致建立两个连接，使得资源浪费。")])]),_._v(" "),e("li",[e("p",[_._v("存在一种SYN_Floud攻击，短时间内由多个ip向服务器发起连接，服务器针对每个ip形成半连接后，这些攻击的主机\n下线，而服务器这边会以为网络不佳，进行重试发送，如果还没有，则会断开这个半连接。这个等待时间称为SYN_Timeout,\n多个ip这样攻击，就会白白消耗资源，使得正常用户卡顿等；\n解决的方法和特征：\n特征：某时段内连接数增多，并且SYN_RECV 连接特别多")]),_._v(" "),e("ul",[e("li",[_._v("缩短这个SYN_Timeout时间")]),_._v(" "),e("li",[_._v("修改重试的次数，有些地方server重试次数高达5次")]),_._v(" "),e("li",[_._v("有个昂贵的东西叫 F5，利用他作为中介，客户先与之连接，连接上后转发到业务服务器。")])])])]),_._v(" "),e("h3",{attrs:{id:"tcp四次挥手断开连接"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp四次挥手断开连接"}},[_._v("#")]),_._v(" TCP四次挥手断开连接")]),_._v(" "),e("p",[_._v("任何一方都可发起断开连接的请求。用主动方、被动方代替。")]),_._v(" "),e("ol",[e("li",[e("p",[_._v("主动方发起请求，将发送包中的FIN位置1，表示准备关闭连接，设置seq序列号m，此时发送方变为 "),e("code",[_._v("FIN_WAIT1")]),_._v("状态")])]),_._v(" "),e("li",[e("p",[_._v("被动方收到后，将包中ACK置1，取到接收到的序列号m 并 加一作为Ack number，并发送一个自己的随机序列号n作为Seq。此时被动方\n状态位"),e("code",[_._v("CLOSE_WAIT")]),_._v("状态，被动方还可发送数据给 主动方，主动方则不能够发了。主动方收到此次后，状态为"),e("code",[_._v("FIN_WAIT2")])])]),_._v(" "),e("li",[e("p",[_._v("待被动方数据传输接受后，会再次发送tcp包，说明自己也可以关闭了。需要将FIN置1，ACK置1，ack number的值还是上一次的m+1，\n但这次的序列号Seq取新的 w。被动方转为"),e("code",[_._v("LAST_ACK")]),_._v("状态")])]),_._v(" "),e("li",[e("p",[_._v("主动方收到后，会发送确认报文，将ACK置1，ack number的值为w+1,这次seq的序列号需要为对方发过来的 m + 1.此时主动方\n状态TIME_WAIT,等待2MSL后，主动方进入CLOSE状态。")])])]),_._v(" "),e("h4",{attrs:{id:"为啥需要等待2msl（2个最大报文生成时间）时间后"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为啥需要等待2msl（2个最大报文生成时间）时间后"}},[_._v("#")]),_._v(" 为啥需要等待2MSL（2个最大报文生成时间）时间后")]),_._v(" "),e("ol",[e("li",[e("p",[_._v("需要保证主动方发送的关闭请求到达被动方了。\n如果最后这次确认报文未送达，处理"),e("code",[_._v("LAST_ACK")]),_._v("的被动方是会重新发送一次上面的第三个FIN ACK包，这样主动方就会再次发送这个关闭\n报文，也会重置2MSL时间等待两方都进入CLOSE状态。")])]),_._v(" "),e("li",[e("p",[_._v("防止已经失效的连接请求报文段出现\n在主动方发送最后确认包2MSL后，此次连接所有报文段都会消失。比如说过了一段时间，这两个ip再次建立连接，\n那肯定不能由上一次遗留的连接在，否则状态混乱。")])])]),_._v(" "),e("h3",{attrs:{id:"网络模型："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#网络模型："}},[_._v("#")]),_._v(" 网络模型：")]),_._v(" "),e("p",[_._v("物理层")]),_._v(" "),e("p",[_._v("数据链路层")]),_._v(" "),e("p",[_._v("网络层")]),_._v(" "),e("p",[_._v("传输层")]),_._v(" "),e("p",[_._v("会话层")]),_._v(" "),e("p",[_._v("表示层")]),_._v(" "),e("p",[_._v("应用层")]),_._v(" "),e("h3",{attrs:{id:"udp"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#udp"}},[_._v("#")]),_._v(" UDP")]),_._v(" "),e("p",[_._v("是一个面向无连接的协议，\n对于发送端来说，应用层给到传输层时，UDP只会将数据加个头标识就传递给网络层了，\n对于接收端，传输层给到应用曾时，就是去掉ip报文头部。")])])}),[],!1,null,null,null);v.default=a.exports}}]);